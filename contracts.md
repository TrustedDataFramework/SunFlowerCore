# TDS 智能合约编写指引 (AssemblyScript 篇)

[TOC]

## AssemblyScript 教程


### AssemblyScript 简介


AssemblyScript 是 TypeScript 的一个变种，和 TypeScript 不同，AssemblyScript 使用严格类型。


### AssemblyScript 基础类型

1. AssemblyScript 的基本类型和对应的 WebAssembly 类型

| AssemblyScript 类型 | WebAssembly 类型 | 描述              |
|---------------------|------------------|-------------------|
| i32                 | i32              | 32 bit 有符号整数 |
| u32                 | u32              | 32 bit 无符号整数 |
| i64                 | i64              | 64 bit 有符号整数 |
| u64                 | u64              | 64 bit 无符号整数 |
| f32                 | f32              | 单精度浮点数      |
| f64                 | f64              | 双精度浮点数      |
| i8                  | i32              | 8 bit 有符号整数  |
| u8                  | i32              | 8 bit 无符号整数  |
| i16                 | i32              | 16 bit 有符号整数 |
| bool                | i32              | 布尔型            |


2. 类型转换

当 AssemblyScript 编译器检查到存在可能不兼容的隐式类型转换时，编译会以异常结果终止。如果需要进行可能不兼容的类型转换，请使用强制类型转换。

在AssemblyScript中，以上提到的每一个类型都有对应的强制转换函数。例如将一个 64 bit 无符号整数 类型的整数强制转换为 32 bit 无符号整数：

```typescript
const i: u64 = 123456789;
const j = u64(i);
```

3. 类型声明

AssemblyScript编译器必须在编译时知道每个表达式的类型。这意味着变量和参数在声明时必须同时声明其类型。如果没有声明类型，编译器将首先假定类型为i32，在数值过大时再考虑 i64，如果是浮点数就是用 f64。如果变量是其他函数的返回值，则变量的类型是函数返回值的类型。此外，所有函数的返回值类型都必须事先声明，以帮助编译器类型推断。

合法的函数：

```typescript
function sayHello(): void{
    log("hello world");
}
```

语法不正确的函数：


```typescript
function sayHello(): {
    log("hello world");
}
```

4. 空值

许多编程语言具有一个特殊的 null 类型表示空值，例如 javascript 和 java 的 null, go 语言和 python 的 nil。事实上 null 类型的引入给程序带来了许多不可预知性，空值检查的遗漏会给智能合约带来安全隐患，因此 TDS 智能合约的编写没有引入 null 类型。


5. 类型转换兼容性

在下表中，列出了所有基本类型的转换兼容性，打勾向表示从左右到右可以进行隐式的类型转换。





| ↱       | bool | i8/u8 | i16/u16 | i32/u32 | i64/u64 | f32 | f64 |
|---------|------|-------|---------|---------|---------|-----|-----|
| bool    | ✓    | ✓     | ✓       | ✓       | ✓       | ✓   | ✓   |
| i8/u8   |      | ✓     | ✓       | ✓       | ✓       | ✓   | ✓   |
| i16/u16 |      |       | ✓       | ✓       | ✓       | ✓   | ✓   |
| i32/u32 |      |       |         | ✓       | ✓       |     | ✓   |
| i64/u64 |      |       |         |         | ✓       |     |     |
| f32     |      |       |         |         |         | ✓   | ✓   |
| f64     |      |       |         |         |         |     | ✓   |


6. 数值比较

当使用比较运算符 ```!=``` 和 ```==``` 时，如果两个数值在类型转换时是兼容的，则不需要强制类型转换就可以进行比较。

操作符 ```>```，```<```，```>=```，```<=``` 对无符号整数和有符号整数有不同的比较方式，被比较的两个数值要么都是有符号整数，要么都是无符号整数，且具有转换兼容性。


7. 移位操作

移位操作符 ```<<```，```>>``` 的结果类型是操作符左端的类型，右端类型会被隐式转换成左端的类型。如果左端类型是有符号整数，执行算术移位，如果左端是无符号整数，则执行逻辑移位。

无符号右移操作符 ```>>>``` 类似，但始终执行逻辑移位。

### 模块化

一个 AssemblyScript 智能合约项目可能由多个文件组成，文件与文件之间可以存在互相引用的关系，互相使用对方导出的内容。。AssemblyScript 项目编译成 wasm 字节码时，需要指定一个入口文件，只有这个入口文件中被导出的函数才可以在将来被调用到。

1. 函数导出


```typescript
export function add(a: i32, b: i32): i32 {
  return a + b
}
```


2. 全局变量导出

```typescript
export const foo = 1
export var bar = 2
```


3. 类导出

```typescript
export class Bar {
    a: i32 = 1
    getA(): i32 { return this.a }
}
```

4. 导入

若建立以下多文件项目，指定 ```index.ts``` 为编译时的入口文件

```sh
indext.ts
foo.ts
```








